#!/reg/d/psdm/cxi/cxilu5617/scratch/python/miniconda3/bin/python3
from __future__ import absolute_import

import warnings
warnings.filterwarnings("ignore")

try: 
    import Tkinter as tk
    import tkFileDialog
    import ttk
except ImportError:
    import tkinter as tk
    from tkinter import filedialog as tkFileDialog
    from tkinter import ttk

from scipy.ndimage.filters import gaussian_filter
from scipy.ndimage.morphology import binary_dilation 
from scipy.ndimage.morphology import binary_erosion
import matplotlib as mpl
mpl.use('TkAgg')
import glob
import time
import sys
import re
import os
import h5py
import numpy as np
import peaks

import matplotlib as mpl
mpl.use('TkAgg')

import pylab as plt

from LineViewer import LineViewer

try:
    from loki.RingData import RadialProfile
    has_loki=True
except ImportError:
    has_loki=False

import imbrowse

btnstyle = {'highlightbackground':'black'}
            

PK_PAR =  { 'make_sparse':True,# leave true.. 
    'sig_G':0.,#'sig_G2':0.1,  # gaussian filter sigma (applied before local max filter, and then applied to streak detect)
    'thresh':10,  # local max with this value pixel (ADU) will be ignored
    'sz':10,  # sub image size used to  do local analysis
    'min_snr': 3,  # min snr, rough compute, optimized visually for each experiment, use this when 'filt' is True
    'filt': False, # this is my janky filtering I prob screwed it up in last commit, email me if bad... 
    'min_dist':8, # min dist between pixels 
    'r_in':None, # min res ring (only detect peaks within this radius
    'r_out':None, 
    'cent':None,  # (fast scan, slow scan) center of pilatus
    'R':None, # provides radius of each pixel, pre-computed... same shape as pilatus
    'rbins': None ,#np.array([0.,225.,300.,375.,450.,525., 600.]),
    'nsigs':4.2, # how many absolute deviations from the median should a local max be to be a peak 
    'min_conn': -1,
    'max_conn':999999,
    'peak_COM':True, # if true uses center of mass (intnsity) to set peak pos, else uses 
    'run_rad_med':False, #whether to use the median radius thresholding
    'mask':None} #mask im

##############


class Peakaboo(tk.Frame):
    
    def __init__(self, master, cxi_fname=None, image_path=None, 
                    run=None, experiment=None, detector=None,
                    circ_color='Limegreen', how="files", *args, **kwargs):
        
        tk.Frame.__init__(self, *args, **kwargs)
        
        self.master = master
        self.master.config(bg="black")

#       attributes
        self.too_many_peaks_val = 1000
        self.radial_bin_circles = []
        self.radial_bins = []
        self.viewing_radpro=False
        self.showing_mask=False
        self.circ_color=circ_color
        self.Num_peaks = 0
        
        self.BASE_MASK = 1
        self.MASK_SCALED = 1
        self.MASK_BEAM = 1
        
        self.found_circs = []
        self.peakaboo=False
        self.mask_join = np.logical_and

#       tab master
        self.nb = ttk.Notebook(self.master)#, style="TNotebook")

#       image browser
        self.nav_frame = tk.Frame( self.nb, bg="black", highlightbackground="#00fa32", highlightthickness=1)
        self.nav_frame.pack( side=tk.TOP, expand=tk.NO)        
        self.browser = imbrowse.BrowseImages( 
            self.master, 
            increment_function=self._update_browser, 
            how=how, 
            h5_fnames =cxi_fname, 
            h5_images_path=image_path,
            psana_experiment_name=experiment,
            psana_run_number=run,
            psana_detector=detector,
            image_nav_frame=self.nav_frame,
            image_frame=None)

#       set peakaboo image class
        self._setup_peakaboo_image_class()

        self._set_info_frame()
        self._make_tooltip_frame()
        
        self._make_peak_detection_frame()
        self._make_mask_and_geometry_frame()
        self._make_peakaboo_inputs()
        self._make_peakaboo_button_frame()
        
        self._make_peakaboo_button()
        self._make_peakaboo_hidepeaks_button()
        self._make_peakaboo_parameter_save_load_buttons()

#       sectionining widgets
        self._make_sectioning_frame()

#       filters
        self._make_imageops_frame()
        self._make_imageops_frame_widgets()

        self.nb.add( self.peak_detection_frame, text="Peaks")
        self.nb.add( self.mask_frame, text="Mask")
        self.nb.add( self.geom_frame, text="Geom")
        self.nb.add( self.sectioning_frame, text="Sectioning")
        self.nb.add( self.nav_frame, text="Navigate")
        self.nb.add( self.imageops_frame, text="Image")

#####################
#       MASK STUFF
#####################
        self._mask_loader()
        self._make_mask_dilation_widgets()
        self._make_active_masking_frame()
        self._mask_values_tool()
        self._mask_accumulate_widget()
        self._make_accumulate_and_mask_button()
#       center / geometry stuff
        self.CENT = (self.browser.IV.img.shape[1]/2., self.browser.IV.img.shape[0]/2.)
        self._set_R()
        self._detector_center_widgets()
        self._set_info_panel()
      
#       radial stuff
        self._make_radial_sectioning_frame()
        self._set_radpro_maker()
        self._set_radial_bin_widgets()
      
        self._set_hover_messages()
        
        self._pack_the_master_frame()
        self._set_window_titles()

    def _make_sectioning_frame(self):
        self.sectioning_frame = tk.Frame( self.nb,
            bg="black",bd=10, 
            highlightbackground="#00fa32", 
            highlightthickness=1)
        
        self.sectioning_frame.pack( side=tk.TOP)
    
    def _make_imageops_frame(self):
        self.imageops_frame = tk.Frame( self.nb,
            bg="black", 
            bd=10,
            highlightbackground="#00fa32", 
            highlightthickness=1)
        
        self.imageops_frame.pack( side=tk.TOP)

    def _make_imageops_frame_widgets(self):
        self._make_filters_frame()
        self._make_gaussian_filter_scale()
        self._make_radpro_button()

    def _make_filters_frame(self):
        self.filters_frame = tk.Frame( self.imageops_frame, bg="black",  
                        highlightbackground="#00fa32", 
                        highlightthickness=2, )
        self.filters_frame.pack(side=tk.TOP, fill=tk.X)
        

    def _make_gauss_blur_toggle_widget(self):
        show_gauss_blur_frame = tk.Frame( self.filters_frame, bg="black")
        show_gauss_blur_frame.pack(side=tk.TOP)
        
        tk.Label(show_gauss_blur_frame, text="Display Gaussian blur", 
                        fg="#00fa32", bg="black").pack(side=tk.LEFT)
        
        self.show_gauss_blur_var = tk.IntVar()
        
        cb = tk.Checkbutton( show_gauss_blur_frame, variable=self.show_gauss_blur_var,
            command=self._show_gauss_blur, bg="black")
        cb.pack( side=tk.LEFT)

    def _show_gauss_blur(self):
        if self.show_gauss_blur_var.get()==1:
            self.browser.IV.set_data( self.PK_IMG.img)
        else:
            self.browser.IV.set_data( self.browser.IV.img)

    def _setup_peakaboo_image_class(self):
        self.PK_IMG = peaks.PeakabooImage( PK_PAR, self.browser.IV.img.shape, 
                            how_to_section=None)

    def _make_radial_sectioning_frame(self):
        self.radsectioning_frame = tk.Frame( self.sectioning_frame, bg='black', 
                                            padx=5, pady=5,
            highlightcolor="#00fa32", highlightthickness=2, bd=10,
                                    highlightbackground="#00fa32")
        self.radsectioning_frame.pack(side=tk.TOP, expand=tk.NO, fill=tk.X)

        tk.Label(self.radsectioning_frame, text="Radial sectioning",
                                fg="#00fa32", bg='black' , font= 'Helvetica 14 bold')\
                                .pack(side=tk.TOP)

    def _pack_the_master_frame(self):
        self.nb.pack( side=tk.TOP, expand=tk.YES)
        self.info_frame.pack( side=tk.TOP, expand=tk.YES, fill=tk.X)

    def _set_window_titles(self):
        self.browser.IV.image_frame.master.title("Peakaboo image")
        self.browser.im_view_fr.title("Peakaboo image range slider")
    
    def _set_info_frame(self):
        self.info_frame = tk.Frame( self.master, bg="black")
    
    def _set_hover_messages(self):
        self._hover_message( self.browser.IV.range_slider.entry_maxval,  
                                        "maximum color scale" )
        self._hover_message( self.browser.IV.range_slider.entry_minval,  
                                    "minimum color scale" )
        self._hover_message( self.browser.IV.range_slider.canvas,  "adjust color scale" )
        
        self._hover_message( self.peakaboo_button, "Peakaboo: Click to detect peaks")
        self._hover_message( self.save_param_button, "Save peak parameters to hdf5")
        self._hover_message( self.load_param_button, "Load peak parameters from hdf5")
        self._hover_message( self.hide_peaks_button, "Stop detecting peaks")

    def _make_peak_detection_frame(self):
        self.peak_detection_frame = tk.Frame(self.nb,  bg='black', 
                        highlightbackground="#00fa32", 
            highlightthickness=1, padx=10, pady=10)
        self.peak_detection_frame.pack(side=tk.LEFT, expand=tk.NO)
    
    def _make_mask_and_geometry_frame(self):
        self.mask_frame = tk.Frame(self.nb, bg='black', highlightbackground="#00fa32", 
                        highlightthickness=2, bd=10)
        self.mask_frame.pack(side=tk.TOP, fill=tk.X)
        
        self.geom_frame = tk.Frame(self.nb, bg='black', highlightbackground="#00fa32", 
                        highlightthickness=2, bd=10)
        self.geom_frame.pack(side=tk.TOP, fill=tk.X)
    
    def _make_tooltip_frame(self):
        
        self.tooltip_fr = tk.Frame( self.info_frame, bg='black', bd=10) 
        self.tooltip_fr.grid( row=0, column=0, sticky=tk.W)
        
        self.tooltip_message = tk.Label( self.tooltip_fr, fg="#00fa32",
                            bg="black", text="Widget info displays here")
        self.tooltip_message.pack(side=tk.TOP , expand=tk.NO)


    def _make_disable_detection_checkbutton(self):
        self.detect_peaks_var = tk.IntVar()
        self.detect_peaks_checkbutton = tk.Checkbutton(
            self.peak_detection_frame, 
            variable=self.detect_peaks_var, 
            command=self._disable_peak_detection, bg='black')
        
        self.detect_peaks_label = tk.Label(
            self.peak_detection_frame,  
            bg='black', fg='#00fa32', text="Do not detect peaks")
        self.detect_peaks_var.set(1)
        self.detect_peaks_label.pack(side=tk.LEFT)
        self.detect_peaks_checkbutton.pack(side=tk.LEFT)

    def _disable_peak_detection(self):
        self.peakaboo = False
        self._update_browser()
    
    def _hide_peakaboo_peaks(self):
        self.peakaboo=False
        self._update_browser()

    
    def _radial_bins_from_entry(self):
       
        radial_bin_str = self.radial_bin_var.get()
       
        try:
            self.radial_bins =  list(map( float, radial_bin_str.split(',') ))
        except:
            self.launch_warning("Something wrong with the radial bin string!")
            PK_PAR["rbins"] = None
            return
        
        if not self.radial_bins == sorted( self.radial_bins):
            print (self.radial_bins)
            self.launch_warning( "Radial bins are not sorted!")
            PK_PAR["rbins"] = None
            return

        self.radial_bins = [r for r in self.radial_bins if r <= self.R.max() ] 

        if 0 not in self.radial_bins:
            self.radial_bins = [0] + self.radial_bins
        
        if self.R.max() not in self.radial_bins:
            self.radial_bins.append( self.R.max() )

        PK_PAR["rbins"] = np.array( self.radial_bins ) 

        self._reset_radial_bins()

    def _reset_radial_bins( self, ):
        
        self.browser._remove_patch_collections(label="radial_bin_circles")
        self.radial_bin_circles = []
        #while self.radial_bin_circles:
        #    circ = self.radial_bin_circles.pop()
        #    if circ in self.browser.IV.ax.patches: 
        #        self.browser.IV.ax.patches.remove(circ)
        x = self.CENT[0]/self.browser.IV.binning_factor
        y = self.CENT[1] / self.browser.IV.binning_factor
        for r in self.radial_bins:
            circ = mpl.pyplot.Circle(xy=(x,y),
                radius=r/self.browser.IV.binning_factor, 
                fc='none', ec='w', ls='dashed', lw=2)
            self.radial_bin_circles.append( circ)
        
        self._show_radial_bins()

    def _hide_radial_bins(self):
        self.browser._remove_patch_collections( label="radial_bin_circles")
        self.browser.IV.update_master_image()
        
        self.show_rbins=False

    def _show_radial_bins(self):
        self.browser._add_patches(self.radial_bin_circles, label="radial_bin_circles", 
            facecolor='none', edgecolor='w', linestyle='dashed', linewidth=2)
        self.browser.IV.update_master_image()
        #for circ in self.radial_bin_circles:
        #    if circ not in self.browser.IV.ax.patches:
        #        self.browser.IV.ax.add_patch( circ)
        
        #self.browser.IV.fig.canvas.draw()
        self.show_rbins=True

    def _set_radial_bin_widgets(self):
        entry_frame =  tk.Frame( self.radsectioning_frame, bg="black")
        entry_frame.pack(side=tk.TOP, fill=tk.X)

        some_text = """List of radial bin dividers for sectioning image.\nEnter a comma separated string e.g. 0,400,600"""
        tk.Label(entry_frame, text=some_text, justify=tk.LEFT, fg="#00fa32", 
                        bg='black')#.pack(side=tk.TOP) 
        
        self.radial_bin_var = tk.StringVar()
        tk.Entry(entry_frame, textvariable=self.radial_bin_var, fg="#00fa32",
                        bg='black',selectforeground="black",\
            selectbackground="#00fa32", insertbackground="#00fa32" )\
                    .pack( side=tk.TOP, pady=10, padx=10, fill=tk.X)
        
        button_frame = tk.Frame( self.radsectioning_frame, bg="black", bd=5)
        button_frame.pack( side=tk.TOP, expand=tk.YES, fill=tk.BOTH)
        tk.Button( button_frame, text="Set", command=self._radial_bins_from_entry, 
                        highlightbackground='black')\
                        .pack(side=tk.LEFT,expand=tk.YES,fill=tk.X)
        tk.Button(button_frame, text="Show", command=self._show_radial_bins,
                                highlightbackground='black')\
                            .pack(side=tk.LEFT,expand=tk.YES,fill=tk.X)
        tk.Button(button_frame, text="Hide", command=self._hide_radial_bins, 
                            highlightbackground='black')\
                            .pack(side=tk.LEFT, expand=tk.YES,fill=tk.X)
        

    def _make_radpro_button(self):
       
        fr = tk.Frame( self.imageops_frame, bg="black", bd=10)
        fr.pack(side=tk.TOP, )
        self.radpro_var = tk.IntVar()
        self.radpro_button = tk.Button(fr, text="Display radial profile", 
            command=self._display_radpro, highlightbackground="black",width=30, 
                            highlightthickness=2 ).pack(side=tk.TOP)
        self.radpro_var.set(0)

    def _display_radpro(self):
        if not has_loki:
            self.launch_warning("You must install LOKI before viewing radial profiles!")
            return
        
        radpro_yvals = self.radpro_maker.calculate( self.browser.IV.img)
        
        self.radpro_fr = tk.Toplevel(self.master)
        #if self.radpro_var.get():
        self.LV = LineViewer(
            self.radpro_fr,
            line_data=(self.radpro_xvals, radpro_yvals) , 
            xlabel="pixel radius", 
            ylabel="Average intensity")
        self.LV.pack(fill=tk.BOTH, expand=tk.YES)
        self.LV.canvas.draw()
        self.viewing_radpro = True

    def _update_radpro(self):
        radpro_yvals = self.radpro_maker.calculate( self.browser.IV.img)
        line_data=(self.radpro_xvals, radpro_yvals)
        self.LV.update_data( line_data)
        self.LV.canvas.draw()

    def _set_radpro_maker(self):
        if has_loki:
            self.radpro_maker = RadialProfile( 
                center=self.CENT,
                img_shape = self.browser.IV.img.shape, 
                mask=PK_PAR["mask"], 
                minlength=  10+ int( np.sqrt( self.browser.IV.img.shape[0]**2 + \
                        self.browser.IV.img.shape[1]**2)) ) 
            
            self.radpro_xvals = np.arange( self.radpro_maker.minlength )

    def _set_info_panel(self):
        
        fr = tk.Frame(self.info_frame, bg="black") # highlightbackground="#00fa32")
        self.info_frame.grid_columnconfigure(1,weight=1)
        fr.grid(row=0, column=2, sticky=tk.E)
        
        color={"foreground":"#00fa32", "background":"black"}
        font = 'Helvetica 10'
        tk.Label(fr, text="Detector shape (ss,fs)=%d,%d"%(self.browser.IV.img.shape[0],
                    self.browser.IV.img.shape[1]),font=font, **color)\
                    .pack( side=tk.TOP)
        self.center_lab_text = "Detector center (ss,fs)=%d,%d"
        self.center_lab = tk.Label(fr, text=self.center_lab_text%(self.CENT[1], 
                    self.CENT[0]), font=font, **color)
        self.center_lab.pack( side=tk.TOP)
        
        self.npeaks_lab_text = "Found peaks: %d"
        self.npeaks_lab = tk.Label(fr, text=self.npeaks_lab_text%self.Num_peaks,
                        font=font,**color)
        self.npeaks_lab.pack( side=tk.TOP)

    def _detector_center_widgets(self):

        fr = tk.Frame( self.geom_frame, background="black",
            highlightthickness=2, bd=5,highlightbackground="#00fa32")
        fr.pack(side=tk.TOP, fill=tk.X)
        
        self.centX_var = tk.DoubleVar()
        self.centY_var = tk.DoubleVar()
        
        color={"foreground":"#00fa32", "background":"black"}
        
        title_frame = tk.Frame( fr, bg="black" )
        title_frame.pack( side=tk.TOP,)
        tk.Label(title_frame, text="Set detector center", font= 'Helvetica 14 bold',
                **color)\
                .pack( side=tk.TOP)

        
        ex_frame = tk.Frame( fr, bg="black")
        ex_frame.pack( side=tk.TOP)
        ex=tk.Entry( ex_frame, textvariable=self.centX_var, width=5)
        ex.pack( side=tk.LEFT, expand=tk.YES, padx=3,pady=3)
        tk.Label(ex_frame, text="fast-scan",width=8,**color)\
                    .pack( side=tk.LEFT, expand=tk.YES)
        
        ey_frame = tk.Frame( fr, bg="black",)
        ey_frame.pack( side=tk.TOP)
        ey = tk.Entry( ey_frame, textvariable=self.centY_var, width=5)
        ey.pack( side=tk.LEFT, expand=tk.YES, padx=3,pady=3)
        tk.Label(ey_frame, text="slow-scan",width=8, **color)\
                    .pack( side=tk.LEFT, expand=tk.YES)
        
        tk.Button(fr, text="Set", width=16,highlightbackground="black", \
            command=self._set_center,).pack( side=tk.TOP, expand=tk.NO,pady=3)
        
        ey.config({"bg": "black", "insertbackground":"#00fa32",
                    "selectforeground":"black", "selectbackground":"#00fa32"})
        ex.config({"bg": "black",  "insertbackground":"#00fa32",
                    "selectforeground":"black", "selectbackground":"#00fa32"})
        self.centX_var.set(self.CENT[0])
        self.centY_var.set(self.CENT[1])
        ey.config({"fg": "#00fa32"})
        ex.config({"fg": "#00fa32"})
        
    def _set_center(self):
        X = self.centX_var.get()
        Y = self.centY_var.get()
        self.CENT = (X,Y)
        PK_PAR['cent'] = self.CENT
        self.center_lab.config(text=self.center_lab_text%(self.CENT[1], self.CENT[0]))
        self._set_radpro_maker()
    
        self._set_R()
        self._reset_radial_bins()
        self._update_beam_mask( self.beam_mask_scale.get())

    def _sel_files(self):
        file_opt = {'filetypes': [],
                    'initialdir': os.getcwd()}
        filename = tkFileDialog.askopenfilename(**file_opt)
        return filename

    def _load_numpy_binary(self, obj_name):
        npy_file = self._sel_files()
        if not npy_file:
            return None ,None
        try:
            NPY = np.load( npy_file)
        except:
            self.launch_warning( "%s is not a numpy binary!"%npy_file )
            NPY = None
        
        if type(NPY) == np.ndarray:
            if NPY.shape != self.browser.IV.img.shape:
                self.launch_warning( "Shape mis-align: %s (%d,%d) and img (%d,%d)!"\
                            %(obj_name, NPY.shape[0], 
                            NPY.shape[1], self.browser.IV.img.shape[0], 
                            self.browser.IV.img.shape[1]) )
                NPY= None
        return npy_file, NPY 
    
    def _show_img_with_mask( self):
        self.showing_mask=True

        mask = self.mask_join( self.BASE_MASK, self.MASK_SCALED) * self.MASK_BEAM
        
        self.browser.IV.set_data( self.browser.IV.img , mask=mask)
        self.browser.IV.fig.canvas.draw()
    
    def _hide_mask( self):
        self.browser.IV.set_data( self.browser.IV.img )
        self.browser.IV.fig.canvas.draw()
        self.showing_mask=False

    def _load_mask_from_file(self):
        self.mask_file, self.BASE_MASK = self._load_numpy_binary("MASK")
       
        if self.BASE_MASK is None:
            self.BASE_MASK = 1

        if has_loki: 
            self._set_radpro_maker()
            if self.viewing_radpro:
                self._update_radpro()
        
        #self.mask_loaded_label.config(text="%s"%os.path.basename(self.mask_file))

        self._set_new_mask()

    def _save_mask(self):
        #if self.BASE_MASK is None and self.MASK_BEAM ==1:
        #    self.launch_warning("No mask loaded")
        #    return
        
        fname = tkFileDialog.asksaveasfilename(defaultextension=".npy")
        if fname=="":
            return
        np.save( fname, self.mask_join( self.BASE_MASK, self.MASK_SCALED) *self.MASK_BEAM )
        print("Saved %s"%fname)

    def _set_R(self):
        #self.R_file, self.R = self._load_numpy_binary("Rpixels")
        
        Yvals, Xvals = np.indices( self.browser.IV.img.shape)
        self.R = np.sqrt( (Yvals-self.CENT[1])**2 + (Xvals-self.CENT[0])**2 ) 
        PK_PAR["R"] = self.R

    def _update_beam_mask(self, scale):
        scale = int(scale)
        self.MASK_BEAM = self.R > scale
        self._show_img_with_mask()

    def _make_gaussian_filter_scale(self):
        
        self.gauss_scale_frame = tk.Frame( self.filters_frame,
            bg="black") 
        self.gauss_scale_frame.pack(side=tk.TOP)

        tk.Label(self.gauss_scale_frame, text="Gaussian filter sigma", fg="#00fa32", 
                bg="black").pack(side=tk.TOP)
        self.gauss_filt_scale = tk.Scale( self.gauss_scale_frame,  fg="#00fa32", 
                bg='black', length=200,highlightbackground="#00fa32", highlightthickness=0,
                command=self._set_gaussian_filter_value, from_=0, to=5,resolution=0.05,
                orient=tk.HORIZONTAL)
        self.gauss_filt_scale.pack(side=tk.TOP, pady=5)

    def _set_gaussian_filter_value(self, scale_factor):
        
        scale_factor = float( scale_factor)
        PK_PAR['sig_G'] = scale_factor

        new_mask = self.mask_join( self.BASE_MASK, self.MASK_SCALED )*self.MASK_BEAM
        img = new_mask * self.browser.IV.img
        
        self.browser.IV.set_data( gaussian_filter( img, scale_factor) )
        self.pk_par_vars["sig_G"].set( str(scale_factor))

    def _make_mask_dilation_widgets(self):
        self.mask_dilate_frame = tk.Frame( self.mask_operations_frame,  bg='black', pady=7)
        self.mask_dilate_frame.pack(side=tk.TOP)
        
        self.dilate_scale = tk.Scale( self.mask_dilate_frame,length=100, fg="#00fa32", bg='black' ,
            label="dilation factor", highlightbackground="#00fa32", highlightthickness=1,
            command=self._update_mask, from_=-50, to=50, orient=tk.HORIZONTAL)
        self.dilate_scale.pack(side=tk.LEFT, padx=5, expand=tk.YES, fill=tk.X)
        
        self.beam_mask_scale = tk.Scale( self.mask_dilate_frame,length=100, fg="#00fa32", bg='black' ,
            label="beam mask", highlightbackground="#00fa32", highlightthickness=1,
            command=self._update_beam_mask, from_=0, to=150, orient=tk.HORIZONTAL)
        self.beam_mask_scale.pack(side=tk.LEFT, padx=5, expand=tk.YES, fill=tk.X)


    def _set_new_mask(self):
        new_mask = self.mask_join( self.BASE_MASK, self.MASK_SCALED )*self.MASK_BEAM
        
        #else:
        #    new_mask = self.MASK_BEAM

        PK_PAR["mask"] = new_mask
        self.PK_IMG.set_mask( new_mask)
        self.PK_IMG.reset_sectioning()

    def _update_mask(self, scale_factor):
        scale_factor = int(scale_factor)
        if type(self.BASE_MASK)==np.ndarray:
            lognot = np.logical_not
            if scale_factor > 0:
                self.MASK_SCALED = lognot(binary_dilation( lognot(self.BASE_MASK), iterations=scale_factor)) 
                self.mask_join = np.logical_and
            elif scale_factor < 0:
                self.MASK_SCALED = lognot(binary_erosion( lognot(self.BASE_MASK), iterations=abs(scale_factor))) 
                self.mask_join = np.logical_or
            else:
                self.MASK_SCALED=1
                self.mask_join = np.logical_and
            
            self._show_img_with_mask()



    def _mask_accumulate_widget(self):
        mask_accumulate_fr = tk.Frame( self.active_masking_frame, bg="black")
        mask_accumulate_fr.pack(side=tk.TOP, expand=tk.YES, fill=tk.X, pady=10)
        
        
        entry_fr = tk.Frame( mask_accumulate_fr, bg="black")
        entry_fr.pack(side=tk.TOP, expand=tk.YES, pady=5)

        self.mask_accumulate_var = tk.IntVar()
        self.mask_accumulate_entry = tk.Entry(entry_fr, width=7, 
                        textvariable=self.mask_accumulate_var)
        self.mask_accumulate_entry.config(bg="black", fg="#00fa32",
                        selectforeground="black", selectbackground="#00fa32", 
                        insertbackground='#00fa32', font="Helvetica 14")
        self.mask_accumulate_var.set(1)

        tk.Label(entry_fr, text="Average shots before masking values", 
            font="Helvetica 14", bg="black", fg="#00fa32")\
            .pack(side=tk.LEFT)
        self.mask_accumulate_entry.pack(side=tk.LEFT)
       
        button_fr = tk.Frame( mask_accumulate_fr, bg="black")
        button_fr.pack(side=tk.TOP, expand=tk.YES, pady=5)
        
        self.use_median_to_accumulate = tk.IntVar()
        self.mask_with_median_button = tk.Checkbutton( button_fr, 
            variable=self.use_median_to_accumulate, bg="black",
            command=self._set_median_accumulate)
        
        self.use_mean_to_accumulate = tk.IntVar()
        self.mask_with_mean_button = tk.Checkbutton( button_fr, 
            variable=self.use_mean_to_accumulate, bg="black",
            command=self._set_mean_accumulate)
        
        tk.Label(button_fr, text="Median accumulate", font="Helvetica 14", bg="black", fg="#00fa32" )\
            .pack(side=tk.LEFT)
        self.mask_with_median_button.pack(side=tk.LEFT)
        tk.Label(button_fr, text="Mean accumulate", font="Helvetica 14", bg="black", fg="#00fa32" )\
            .pack(side=tk.LEFT)
        self.mask_with_mean_button.pack(side=tk.LEFT)
        
        self.use_median_to_accumulate.set(1)
        self.use_mean_to_accumulate.set(0)
   
    def _make_accumulate_and_mask_button(self):
        fr = tk.Frame( self.active_masking_frame, bg="black")
        fr.pack(side=tk.TOP, pady=10)
        
        tk.Button( fr,  text="Accumulate and mask",width=30, 
             highlightbackground="black", command=self._accumulate_and_mask)\
            .pack(side=tk.TOP, expand=tk.YES, fill=tk.X)

    def _accumulate_and_mask(self):
        pass

    def _set_median_accumulate(self):
        self.use_median_to_accumulate.set(1)
        self.use_mean_to_accumulate.set(0)
    
    def _set_mean_accumulate(self):
        self.use_median_to_accumulate.set(0)
        self.use_mean_to_accumulate.set(1)
       
    def _make_active_masking_frame(self):
        self.active_masking_frame = tk.Frame( self.mask_operations_frame, 
            bg="black", highlightbackground="#fa0032", bd=2)
        self.active_masking_frame.pack(side=tk.TOP, expand=tk.YES, pady=10)
        

    def _mask_values_tool(self):
        mask_values_fr = tk.Frame( self.active_masking_frame , bg="black") 
        mask_values_fr.pack(side=tk.TOP, expand=tk.YES, pady=10)
        
        self.mask_below_var = tk.DoubleVar()
        self.mask_below_entry = tk.Entry(mask_values_fr, width=7, textvariable=self.mask_below_var)
        self.mask_below_entry.config(bg="black", fg="#00fa32",
            selectforeground="black", selectbackground="#00fa32", 
            insertbackground='#00fa32', font="Helvetica 14")
        
        self.mask_above_var = tk.DoubleVar()
        self.mask_above_entry = tk.Entry(mask_values_fr, width=7, textvariable=self.mask_above_var)
        self.mask_above_entry.config(bg="black", fg="#00fa32",
            selectforeground="black", selectbackground="#00fa32", 
            insertbackground='#00fa32', font="Helvetica 14")
        self.mask_above_var.set(65534)
        
        tk.Label(mask_values_fr, bg='black', fg='#00fa32', text='mask below',  
            font="Helvetica 14", width=10)\
            .pack(side=tk.LEFT)
        self.mask_below_entry.pack(side=tk.LEFT)
        tk.Label(mask_values_fr, bg='black', fg='#00fa32', text='mask above', 
            font="Helvetica 14",  width=10)\
            .pack(side=tk.LEFT)
        self.mask_above_entry.pack(side=tk.LEFT)
      



    
    def _mask_loader(self):
        fr = tk.Frame(  self.mask_frame, bg='black', padx=3, pady=3,highlightbackground="#00fa32", highlightthickness=2)
        fr.pack(side=tk.TOP, fill=tk.X )
        self.mask_operations_frame = fr
        
        title_fr=tk.Frame( fr, bg="black",)
        title_fr.pack(side=tk.TOP,)
        tk.Label(title_fr, text="Mask operations", fg="#00fa32", bg='black', font='Helvetica 14 bold').pack(side=tk.TOP) 

        mask_load_fr = tk.Frame( fr, bg="black")
        mask_load_fr.pack(side=tk.TOP,expand=tk.YES, fill=tk.X )
        
        self.mask_loaded_label = tk.Label(mask_load_fr, text="Load a numpy binary mask (.npy)", 
            highlightbackground="#00fa32", 
            highlightthickness=0, bg='black',
            fg="#00fa32")
        #self.mask_loaded_label.pack(side=tk.LEFT,)
        
        tk.Button(mask_load_fr, text="Load" , relief=tk.RAISED, highlightbackground="black", command=self._load_mask_from_file)\
            .pack(side=tk.LEFT, fill=tk.X, expand=tk.YES)
        tk.Button(mask_load_fr, text="Save" , relief=tk.RAISED, highlightbackground="black", command=self._save_mask)\
            .pack(side=tk.LEFT, fill=tk.X, expand=tk.YES)
       
        
        tk.Button(mask_load_fr, text="Show" , relief=tk.RAISED, highlightbackground="black", 
            command=self._show_img_with_mask)\
            .pack(side=tk.LEFT,expand=tk.YES, fill=tk.X)
        tk.Button(mask_load_fr, text="Hide" , relief=tk.RAISED, 
            highlightbackground="black", command=self._hide_mask)\
            .pack(side=tk.LEFT, expand=tk.YES,fill=tk.X)
        
        tk.Button(mask_load_fr, text="Set", 
            command=self._set_new_mask, highlightbackground="black", relief=tk.RAISED)\
            .pack( side=tk.LEFT, fill=tk.X, expand=tk.YES)
         
    def _R_loader(self):
        fr = tk.Frame(  self.peak_detection_frame)
        fr.pack(side=tk.TOP, expand=tk.YES, fill=tk.BOTH)
        
        tk.Button(fr, text="Load a pixel-radius file (numpy binary .npy)" , 
            command=self._set_R)\
            .pack(side=tk.LEFT, expand=tk.YES)

    def make_number_entries(self):
        color = {"fg":"#00fa32", "bg":"black"}
        _fr = tk.Frame( self.peak_detection_frame, 
            bg="black", highlightbackground="#00fa32", 
            highlightthickness=2)
        _fr.pack(side=tk.TOP, expand=tk.YES, fill=tk.BOTH)
        
        fr = tk.Frame( _fr, bg="black")
        fr.pack(side=tk.TOP, expand=tk.YES, fill=tk.BOTH, padx=10,pady=10)

        self.pk_par_vars ={}
        self.all_number_entry_widgets = {}
        for row,e in enumerate(self.number_entries.keys()):
            
            self.pk_par_vars[e] = tk.StringVar()
            entry = tk.Entry(fr, textvariable=self.pk_par_vars[e],width=5) # **color)
            entry.grid( row=row, column=0,pady=4) 
            self.pk_par_vars[e].set( str(PK_PAR[e]))
            
            entry.config(bg="black", fg="#00fa32",selectforeground="black", selectbackground="#00fa32",  
                highlightcolor="#00fa32", insertbackground="#00fa32")
            tk.Label(fr, text=self.number_info[e], justify=tk.LEFT, anchor=tk.W, \
                highlightbackground="#00fa32", highlightthickness=0,pady=2, **color).grid(row=row, column=1, sticky=tk.W)
    
            self.all_number_entry_widgets[e] = entry

    def make_bool_entries(self):
        hlcolors={"highlightbackground":"#00fa32", "highlightthickness":1}
        colors={"bg":"black", "fg":"#00fa32"}
        fr = tk.Frame( self.peak_detection_frame, bg="black", **hlcolors )
        fr.pack(side=tk.TOP, expand=tk.YES, fill=tk.BOTH, pady=(0,0))
        
        self.bool_checkbuttons = {}
        for row,e in enumerate( self.bool_entries):

            self.pk_par_vars[e] = tk.IntVar()
            sub_fr = tk.Frame( fr, bg="black")
            sub_fr.grid(row=row,column=0, sticky=tk.W, padx=10)
             
            c = tk.Checkbutton(sub_fr, variable=self.pk_par_vars[e],
                                anchor="w", justify=tk.LEFT, command=self.bool_cmd[e], bg="black")
            c.pack(side=tk.LEFT)
            tk.Label(sub_fr, text=self.bool_info[e], bg="black", fg="#00fa32").pack(side=tk.LEFT)
            self.bool_checkbuttons[e] = c
            self.pk_par_vars[e].set( int(PK_PAR[e]) ) 
            

    def launch_warning(self, proc_mssg, timeout=False):
        warningWindow = tk.Toplevel(self.master)

        tk.Label(warningWindow, text=proc_mssg, background='red', foreground='white', font='BOLD' ).pack()
        if timeout:
            self.master.after( 1000, lambda: warningWindow.destroy() ) 
        else:
            tk.Button( warningWindow, text='OK',command=warningWindow.destroy, relief=tk.RAISED,font='BOLD' ).pack()

    def _make_peakaboo_inputs(self):
        self.number_entries = {  "sig_G":float, "nsigs":float, 
            "min_snr":float, "sz":int, "r_in":float, "r_out":float, 
            "min_dist":float, "thresh":float , 
            "min_conn": int, "max_conn": int}
        
        self.number_info = {  "sig_G":"Gaussian blur", 
            "nsigs":"Minimum standard devitions from mean", 
            "min_snr":"Minimum SNR", 
            "sz":"SNR box size", 
            "r_in":"Only detect inside this pixel radius", 
            "r_out":"Only detect outside this pixel radius", 
            "min_dist":"Minimum separation of peaks", 
            "thresh":"Minimum ADU for a peak" , 
            "min_conn": "Minimum connected pixels in peak", 
            "max_conn": "Maximum connected pixels in peak"}
       
        #str_entries = {"mask":str, "R":str}
        self.bool_entries = {"filt":bool, "run_rad_med":bool, "peak_COM":bool}
        self.bool_info={"filt":"Minimum SNR filter", 
                        "run_rad_med":"Use radial median subtraction",
                        "peak_COM":"Detect peak center-of-intensity"} 
        
        def check_run_rad_med():
            if self.R is None:
                self.launch_warning("Define or load a radial pixel map first!")
                self.pk_par_vars["run_rad_med"].set(0)
                return
            
            if PK_PAR["rbins"] is None:
                self.launch_warning("Define radial bins (Mask/Geom tab) or this is meaningless")
                self.pk_par_vars["run_rad_med"].set(0)
                return
            
            self.PK_IMG.set_pk_par( PK_PAR)
            self.PK_IMG._set_up_sectioning(how="radial")


        def disable_snr_buttons():
            if self.pk_par_vars["filt"].get()==0:
                self.all_number_entry_widgets["min_snr"].config(state=tk.DISABLED)
                self.all_number_entry_widgets["sz"].config(state=tk.DISABLED)
            else:
                self.all_number_entry_widgets["min_snr"].config(state=tk.NORMAL)
                self.all_number_entry_widgets["sz"].config(state=tk.NORMAL)
        
        bool_cmd = {"run_rad_med": check_run_rad_med, "filt": disable_snr_buttons}

        self.bool_cmd = dict([(k,bool_cmd[k]) if k in bool_cmd else (k,lambda:None) 
            for k in self.bool_info.keys() ])

        tk.Label(self.peak_detection_frame, text="Peak finding parameters", bg='black', fg="#00fa32", \
            highlightbackground="#00fa32",  font= 'Helvetica 14 bold', highlightthickness=0).pack(side=tk.TOP,)
        
        self.make_number_entries()
        self.make_bool_entries()
        
        if not PK_PAR["filt"]:
            disable_snr_buttons()

        self.entry_type ={k:v for d in [self.number_entries, self.bool_entries] 
                            for k, v in d.items()} 
        
       
    def _make_peakaboo_button_frame(self):
        self.peakaboo_button_frame = tk.Frame( self.peak_detection_frame, 
            bg='black', highlightthickness=1,bd=7, highlightbackground="#00fa32" )
        self.peakaboo_button_frame.pack(side=tk.TOP, expand=tk.YES, fill=tk.BOTH)
    

        bool_cmd = {"run_rad_med": check_run_rad_med}

        self.bool_cmd = dict([(k,bool_cmd[k]) if k in bool_cmd else (k,lambda x:None) 
            for k in self.bool_info.keys() ])

        tk.Label(self.peak_detection_frame, text="Peak finding parameters", bg='black', fg="#00fa32", \
            highlightbackground="#00fa32",  font= 'Helvetica 14 bold', highlightthickness=0).pack(side=tk.TOP,)
        self.make_number_entries()
        self.make_bool_entries()
        self.entry_type ={k:v for d in [self.number_entries, self.bool_entries] 
                            for k, v in d.items()} 
        
       
    def _make_peakaboo_button_frame(self):
        self.peakaboo_button_frame = tk.Frame( self.peak_detection_frame, 
            bg='black', highlightthickness=1,bd=7, highlightbackground="#00fa32" )
        self.peakaboo_button_frame.pack(side=tk.TOP, expand=tk.YES, fill=tk.BOTH)
    
    def _make_peakaboo_button(self):
        
        self.peakaboo_button = tk.Button( self.peakaboo_button_frame,  
            text="Peakaboo!", 
            command=self._on_peakaboo, 
            highlightthickness=1, 
            highlightbackground='black')
        
#       just trying this out for fun
        self.peakaboo_button.pack(side=tk.LEFT, expand=tk.YES, fill=tk.X)

    def _make_peakaboo_parameter_save_load_buttons(self):
        button_style = {"highlightthickness":1, "highlightbackground":"black"}
        
        self.save_param_button = tk.Button( self.peakaboo_button_frame,  
                text="Save", command=self._save_peak_params, **button_style)
        self.save_param_button.pack(side=tk.LEFT, fill=tk.X, expand=tk.YES)
        
        self.load_param_button = tk.Button( self.peakaboo_button_frame ,text="Load", command=self._load_peak_params, **button_style)
        self.load_param_button.pack(side=tk.LEFT, fill=tk.X, expand=tk.YES)


    def _make_quit_button(self):
        button_style = {"highlightthickness":1, "highlightbackground":"black"}
        self.quit_button=tk.Button(self.peakaboo_button_frame, text='Quit', command=self._close_application, **button_style)
        self.quit_button.pack(side=tk.LEFT, fill=tk.X, expand=tk.YES)

    def _close_application(self):
        self.master.destroy()

    def _make_peakaboo_hidepeaks_button(self):
        button_style = {"highlightthickness":1, "highlightbackground":"black"}
        self.hide_peaks_button = tk.Button( self.peakaboo_button_frame, 
            text="Hide", command=self._hide_peakaboo_peaks, **button_style)
        self.hide_peaks_button.pack(side=tk.LEFT, expand=tk.YES, fill=tk.X)


    def _hover_message(self, widget, message):
        widget.bind( "<Enter>", lambda event,x=message:self._on_enter(event, message=x))
        widget.bind("<Leave>", self._on_leave)

    def _on_peakaboo( self):
        self.peakaboo=True
        #self.detect_peaks_var.set(0)
        self._update_browser()

#   tool tip message bindings, can be used for any widgets... 
    def _on_enter( self, event, message=""):
        self.tooltip_message.config(text=message)
    
    def _on_leave( self, event, message="Widget info displays here"):
        self.tooltip_message.config(text=message)

    def _set_found_circs(self):
        self.found_circs = []
        for cent in self.found_centers:
            x = cent[1] / self.browser.IV.binning_factor
            y = cent[0] / self.browser.IV.binning_factor
            circ = mpl.patches.Circle(
                xy=(x,y), radius=7./self.browser.IV.binning_factor, ec=self.circ_color, fc='none', lw=1)
            self.found_circs.append( circ)
    
    def _detect_peaks(self):
        self._detection()
        self._set_found_circs()
        
    def _save_peak_params(self):
        fname = tkFileDialog.asksaveasfilename(defaultextension=".h5")
        
        if fname =="":
            return
       
        # above file dialogue asks to overwrite.
        if os.path.exists(fname):
            os.remove( fname)
        
        with h5py.File(fname,'w') as h5:
            for name,data in PK_PAR.items():
                print (name,data)
                if name =="_NULL":
                    launch_warning("Something is named _NULL, that is not allowed")
                    return
                
                if data is None:
                    h5.create_dataset(name, data="_NULL")
                else:
                    h5.create_dataset(name, data=data)
             
        return
   
    def _load_peak_params(self):
        filename = self._sel_files() 
        if filename =="":
            return
        with h5py.File(filename, "r") as h5:
            for name in h5.keys():
                data = h5[name].value
                print (name, data )
                if data == "_NULL":
                    data = None
                PK_PAR[name] = data
        
        self.CENT = PK_PAR['cent']
        self.BASE_MASK = PK_PAR['mask']
        if self.BASE_MASK is not None:
            self.BASE_MASK = self.BASE_MASK.astype(bool)
        self.R = PK_PAR['R']
        
        self.centX_var.set( self.CENT[0])
        self.centY_var.set( self.CENT[1])
        self._set_center()
        
        if PK_PAR["rbins"] is not None:
            self.radial_bins = list( PK_PAR['rbins'] ) 
            self.radial_bin_var.set(  ",".join( list(map(lambda x:"%d"%x, self.radial_bins))) )
        
            self._reset_radial_bins()
        
        for e,entry in self.pk_par_vars.items():
            self.pk_par_vars[e].set( PK_PAR[e] )
        for e,cb in self.bool_checkbuttons.items():
            if PK_PAR[e]:
                cb.select()
            else:
                cb.deselect()

        self._update_browser()

    def get_inputs(self):
        for e, entry in self.pk_par_vars.items():
            
            if entry.get() == 'None':
                eget = None
           
            elif entry.get() is None:
                eget = None
            
            else:
                eget = self.entry_type[e] ( entry.get() )
            
            PK_PAR[e] = eget
    
    def _set_npeaks_lab_text(self):
        self.npeaks_lab.config(text=self.npeaks_lab_text%self.Num_peaks)

    def _detection(self):
        
        self.get_inputs()
        
        PK_PAR["cent"] = self.CENT
        
        print(PK_PAR)
        self.found_centers,_ = self.PK_IMG.pk_pos( pk_par=PK_PAR, img=self.browser.IV.img)
        
        self.Num_peaks = len(self.found_centers)
        
        if self.Num_peaks > self.too_many_peaks_val:
            self.launch_warning("Probably too many peaks, change parameters!", timeout=True)
                
        self._set_npeaks_lab_text() 
        print("Found %d peaks"%(len(self.found_centers) ))

    def _update_browser(self):
        
        self.browser._set_idx_fname_path()
        self.browser._set_image()
        self.browser._update_img_info_text()
        
        if self.found_circs:
            self.browser._remove_patch_collections( label="found_circs" )
            self.found_circs = []
        
        if self.peakaboo:
            self._detect_peaks() # this sets found circs 
            self.browser._add_patches( patches=self.found_circs, label="found_circs", edgecolor='Deeppink',
                facecolor='none')
             
        #self.browser._set_xy_limits()
        if self.showing_mask:
            self._show_img_with_mask()
        else:
            self.browser.IV.set_data( self.browser.IV.img)
        
        #self.browser.IV.update_master_image()
        #self.browser.IV.update_zoom_image()
        #self.browser.IV.fig.canvas.draw()
        
        if PK_PAR["sig_G"] is not None:
            self._set_gaussian_filter_value(PK_PAR["sig_G"])

if __name__ == '__main__':
    from argparse import ArgumentParser
    parser = ArgumentParser(
        description='')
    parser.add_argument(
        '-data',
        dest='images_path',
        type=str,
        default='data')

    parser.add_argument(
        '-f, --fname',
        dest='fname',
        type=str,
        default=None)
    
    parser.add_argument(
        '-r',
        dest='run',
        type=int, help='psana run number'
        default=None)
    
    parser.add_argument(
        '--detector',
        dest='detector',
        type=str, help='psana detector string'
        default="DsaCsPad")
    
    parser.add_argument(
        '--experiment',
        dest='experiment',
        type=str, help='psana experiment string'
        default="cxilu5617")
    
    parser.add_argument(
        '--circ-color',
        dest='circ_color',
        type=str,
        default='Deeppink')
    
    args = parser.parse_args()

    if args.run is not None:
        how = 'psana'
    else:
        how = 'files'

    root = tk.Tk()
    root.title("Peakaboo")
    
    frame = Peakaboo(
        root,
        cxi_fname=args.fname,
        images_path=args.images_path,
        run = args.run,
        experiment=args.experiment,
        detector=args.detector,
        circ_color=args.circ_color,
        how = how,
        bg='black' )
    
    def __init__(self, master, cxi_fname=None, image_path=None, 
                    run=None, experiment=None, detector=None,
                    circ_color='Limegreen', how="files", *args, **kwargs):
        
    frame.pack( side=tk.TOP, expand=tk.YES)
    root.mainloop()

